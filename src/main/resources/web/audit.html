<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Audit</title>
  <link rel="stylesheet" href="/web/rollback.css" />
</head>
<body class="page">
  <div class="container">
    <div class="header split">
      <div>
        <h1>Audit</h1>
        <p id="subtitle">Live history from the database</p>
      </div>
      <div class="action-row">
        <a class="button secondary" href="/">‚üµ Rollback</a>
        <button id="btn-refresh" type="button">Refresh now</button>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <div class="card">
      <div class="settings-row">
        <div class="field">
          <label for="token-input">Token</label>
          <input type="password" id="token-input" placeholder="Token" autocomplete="current-password" />
        </div>
        <div class="field">
          <label for="limit-input">Max entries per tab</label>
          <input type="number" id="limit-input" value="100" min="10" max="500" />
        </div>
        <div class="field">
          <label for="auto-interval">Auto refresh (s)</label>
          <div class="split">
            <input type="number" id="auto-interval" value="10" min="3" max="300" />
            <label class="checkbox">
              <input type="checkbox" id="auto-toggle" checked /> enable
            </label>
          </div>
        </div>
      </div>
      <div id="status" class="muted"></div>
      <div class="tabs" role="tablist">
        <button class="tab active" data-tab="chat" role="tab">Chat</button>
        <button class="tab" data-tab="blocks" role="tab">Blocks</button>
        <button class="tab" data-tab="containers" role="tab">Inventory</button>
      </div>
      <div id="panel-chat" class="tab-panel active" role="tabpanel"></div>
      <div id="panel-blocks" class="tab-panel" role="tabpanel"></div>
      <div id="panel-containers" class="tab-panel" role="tabpanel"></div>
    </div>
  </div>

  <script>
    const panels = {
      chat: document.getElementById('panel-chat'),
      blocks: document.getElementById('panel-blocks'),
      containers: document.getElementById('panel-containers')
    };
    const tabs = document.querySelectorAll('.tab');
    const toast = document.getElementById('toast');
    const status = document.getElementById('status');
    const tokenInput = document.getElementById('token-input');
    const limitInput = document.getElementById('limit-input');
    const autoIntervalInput = document.getElementById('auto-interval');
    const autoToggle = document.getElementById('auto-toggle');
    const refreshBtn = document.getElementById('btn-refresh');

    let refreshHandle;

    function savedToken() {
      const fromInput = (tokenInput.value || '').trim();
      if (fromInput) return fromInput;
      const stored = localStorage.getItem('glraToken');
      if (stored) return stored;
      const viaUrl = new URLSearchParams(location.search).get('token');
      return viaUrl || '';
    }

    function applySavedToken() {
      const token = savedToken();
      if (token && !tokenInput.value) tokenInput.value = token;
    }

    function showToast(text, variant = 'info') {
      if (!text) return;
      toast.textContent = text;
      toast.className = `toast ${variant}`;
      toast.setAttribute('aria-hidden', 'false');
      clearTimeout(window.__toastTimeout);
      window.__toastTimeout = setTimeout(() => hideToast(), 6000);
    }

    function hideToast() {
      toast.setAttribute('aria-hidden', 'true');
      toast.className = 'toast';
    }

    function switchTab(id) {
      tabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === id));
      Object.entries(panels).forEach(([key, el]) => {
        el.classList.toggle('active', key === id);
      });
    }

    tabs.forEach(tab => tab.addEventListener('click', () => switchTab(tab.dataset.tab)));

    function headers() {
      const token = savedToken();
      const h = { 'Accept': 'application/json' };
      if (token) h['X-Auth-Token'] = token;
      return h;
    }

    function loadAutoSettings() {
      const storedInterval = parseInt(localStorage.getItem('glraAuditInterval') || '10');
      if (!Number.isNaN(storedInterval)) autoIntervalInput.value = storedInterval;
      const storedToggle = localStorage.getItem('glraAuditAuto');
      if (storedToggle !== null) autoToggle.checked = storedToggle === 'true';
    }

    function saveAutoSettings() {
      localStorage.setItem('glraAuditInterval', autoIntervalInput.value);
      localStorage.setItem('glraAuditAuto', autoToggle.checked ? 'true' : 'false');
    }

    async function loadMeta() {
      try {
        const res = await fetch('/api/audit/meta');
        if (!res.ok) return;
        const data = await res.json();
        if (!data.enabled) {
          status.textContent = 'Audit dashboard is disabled in the config.';
          stopAutoRefresh();
          return false;
        }
        tabs.forEach(tab => {
          const enabled = data[tab.dataset.tab];
          tab.disabled = !enabled;
          if (!enabled) {
            panels[tab.dataset.tab].innerHTML = '<p class="muted">Disabled in config.</p>';
          }
        });
        return true;
      } catch (err) {
        console.warn('Audit meta failed', err);
        return false;
      }
    }

    function renderChat(entries) {
      return renderTable(entries, [
        { label: 'Time', render: e => formatTs(e.ts) },
        { label: 'Player', render: e => escapeHtml(e.player || 'Unknown') },
        { label: 'Message', render: e => escapeHtml(e.message || '') }
      ], 'No chat messages found.');
    }

    function renderBlocks(entries) {
      return renderTable(entries, [
        { label: 'Time', render: e => formatTs(e.ts) },
        { label: 'Player', render: e => escapeHtml(e.player || 'Unknown') },
        { label: 'Action', render: e => `<span class="pill ${blockPillClass(e.action)}">${blockActionLabel(e.action)}</span>` },
        { label: 'Block', render: e => escapeHtml(e.material || 'unknown') },
        { label: 'Location', render: e => `<span class="mono">${escapeHtml(e.level || '')} @ ${e.x},${e.y},${e.z}</span>` }
      ], 'No block actions found.');
    }

    function renderContainers(entries) {
      return renderTable(entries, [
        { label: 'Time', render: e => formatTs(e.ts) },
        { label: 'Player', render: e => escapeHtml(e.player || 'Unknown') },
        { label: 'Action', render: e => `<span class="pill ${containerPillClass(e.action)}">${containerActionLabel(e.action)}</span>` },
        { label: 'Item', render: e => `${e.amount || 0}x ${escapeHtml(e.material || 'unknown')}` },
        { label: 'Location', render: e => `<span class="mono">${escapeHtml(e.level || '')} @ ${e.x},${e.y},${e.z}</span>` }
      ], 'No inventory actions found.');
    }

    function renderTable(entries, columns, emptyText) {
      if (!entries || entries.length === 0) return `<p class="muted">${emptyText}</p>`;
      let header = columns.map(c => `<th>${escapeHtml(c.label)}</th>`).join('');
      let rows = entries.map(e => {
        const cells = columns.map(c => `<td>${c.render(e)}</td>`).join('');
        return `<tr>${cells}</tr>`;
      }).join('');
      return `<table class="audit-table"><thead><tr>${header}</tr></thead><tbody>${rows}</tbody></table>`;
    }

    function formatTs(ts) {
      return new Date(ts).toLocaleString();
    }

    function blockPillClass(code) {
      switch (code) {
        case 0: return 'warning';
        case 1: return 'success';
        default: return 'neutral';
      }
    }

    function containerPillClass(code) {
      switch (code) {
        case 1: return 'success';
        case 0: return 'warning';
        default: return 'neutral';
      }
    }

    function blockActionLabel(code) {
      switch (code) {
        case 0: return 'Break';
        case 1: return 'Place';
        default: return 'Change';
      }
    }

    function containerActionLabel(code) {
      switch (code) {
        case 1: return 'Add to container';
        case 0: return 'Remove from container';
        default: return 'Change container';
      }
    }

    function escapeHtml(text) {
      const map = {"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"};
      return (text || '').replace(/[&<>"']/g, c => map[c] || c);
    }

    async function loadAudit() {
      const limit = Math.min(Math.max(parseInt(limitInput.value || '100'), 10), 500);
      limitInput.value = limit;
      saveAutoSettings();
      try {
        const res = await fetch('/api/audit?limit=' + limit, { headers: headers() });
        if (!res.ok) {
          status.textContent = res.status === 401 ? 'Unauthorized: provide a valid token.' : 'Failed to load audit data.';
          showToast(status.textContent, 'error');
          return;
        }
        const data = await res.json();
        if (!data.enabled) {
          status.textContent = 'Audit dashboard is disabled in the config.';
          stopAutoRefresh();
          return;
        }
        if (data.chatEnabled) panels.chat.innerHTML = renderChat(data.chat || []); else panels.chat.innerHTML = '<p class="muted">Disabled in config.</p>';
        if (data.blockEnabled) panels.blocks.innerHTML = renderBlocks(data.blocks || []); else panels.blocks.innerHTML = '<p class="muted">Disabled in config.</p>';
        if (data.containerEnabled) panels.containers.innerHTML = renderContainers(data.containers || []); else panels.containers.innerHTML = '<p class="muted">Disabled in config.</p>';
        status.textContent = 'Last updated at ' + new Date().toLocaleTimeString();
      } catch (err) {
        status.textContent = 'Error: ' + err;
        showToast('Error while loading audit data', 'error');
      }
    }

    function autoIntervalMs() {
      const seconds = Math.min(Math.max(parseInt(autoIntervalInput.value || '10'), 3), 300);
      autoIntervalInput.value = seconds;
      return seconds * 1000;
    }

    function startAutoRefresh() {
      stopAutoRefresh();
      if (!autoToggle.checked) return;
      refreshHandle = setInterval(loadAudit, autoIntervalMs());
    }

    function stopAutoRefresh() {
      if (refreshHandle) {
        clearInterval(refreshHandle);
        refreshHandle = null;
      }
    }

    refreshBtn.addEventListener('click', () => {
      loadAudit();
    });

    tokenInput.addEventListener('change', () => {
      const value = (tokenInput.value || '').trim();
      if (value) localStorage.setItem('glraToken', value); else localStorage.removeItem('glraToken');
    });

    autoToggle.addEventListener('change', () => {
      saveAutoSettings();
      if (autoToggle.checked) {
        loadAudit();
        startAutoRefresh();
      } else {
        stopAutoRefresh();
      }
    });

    autoIntervalInput.addEventListener('change', () => {
      saveAutoSettings();
      startAutoRefresh();
    });

    applySavedToken();
    loadAutoSettings();
    loadMeta().then(enabled => {
      if (enabled) {
        loadAudit();
        startAutoRefresh();
      }
    });
  </script>
</body>
</html>

